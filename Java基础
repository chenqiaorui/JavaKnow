1.面向对象与面向过程的区别
	面向过程：面向过程的性能比面向对象高。因为类调用时需要实例化，开销大，比较消耗资源，所以当性能是最重要的考量因素的时候
	，比如单片机，嵌入式开发，Linux/Unix等一般采用面向过程开发。
	面向对象: 面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，
	使系统更灵活。
    
面向对象性能比面向对象高？
  java是半编译语言，最终执行代码并不是可以直接被CPU执行的二进制机械码。
2.Java语言有哪些特点？
	1.面向对象；
	2.平台无关性；(JVM)
	3.支持多线程；
	4.支持网络编程。
3.关于JVM JDK和JRE的解答。
	JVM是运行Java字节码的虚拟机。
	
	什么是字节码？
	.class文件。

	java从源码到运行有3步：
	
	JVM类加载气首先加载字节码文件，通过解释器逐行解释执行。JIT编译器编译后会将对应的机器码保存下来，
	下次可直接使用。
	
	总结：
	JVM是运行字节码的虚拟机。
	
	JDK和JRE
	JDK是Java Development Kit,它是功能齐全的Java SDK。它拥有JRE的一切，还有编译器（javac）和
	工具（如javadoc）,它能够创建和编译一切。
	
	JRE是Java运行时环境。它是运行已编译Java编程的所有内容的集合。包括Java虚拟机（JVM）,java类库，
	java命令和其他一些基础构建，但是他不能用于创建新程序。
	
4.Oracle JDK和OpenJDK的对比
	略
5.Java和C++的区别
	都是面向对象的语言，都支持封装、继承、多态性
	Java不提供指针来直接访问内存，程序内存更加安全
	Java的类是单继承，C++支持多继承；虽然类不支持多继承，但是接口可以多继承。
	Java有自动内存管理机制，不需要程序员手动释放无用内存
6.什么是Java程序的主类 应用程序和小程序的主类有何不同
	一个程序中可以有多个类，但只能有一个类是朱磊。在Java应用程序中，这个主类是指包含main()方法的类/
	而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是
	public类，但小程序的主类必须是public类。主类是Java程序执行的入口点。
7.Java应用程序和小程序之间有哪些差别
	简单来讲应用程序是从主线程启动。applet小程序没有main()方法，猪要是嵌在浏览器页面上运行。
8.字符型常量和字符串常量的区别
	1.形式上：字符常量是单引号引起的1个字符；字符串常量是双引号引起的若干个字符
	2.含义上：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中的位置）
	3.占内存大小 字符常量只占2个字节；字符串常量占若干个字节
9.构造器能否被override
	在讲继承的时候我们知道弗雷的私有属性和构造方法不能被继承，所以Constructor不能被重写，但是可以overload(重载)，所以你可以看到一个类中有多个构造函数的情况
10.重载和重写的区别
	重载：发生在同一个类中，方法名必须相同，参数类型、个数不同、顺序不同，方法的返回值和访问修饰符可以不同
	重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写，发生在子类中，方法名和参数列表必须相同，返回值范围小于等于父类，
	抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为private，则该子类就不能重写该方法。
	也就是说方法提供的行为改变，而方法的外貌并没有改变。
11.Java面向对象编程三大特性:封装 继承 多态性
	封装
	封装把对象的属性私有化，同时提供一些可以被外界访问属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是
	如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。
	
	继承
	继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或者新的功能。也可以用父类的功能，但不能选择性地
	继承父类。通过继承我们能够非常方便以前的代码。
	
	关于继承的3点：
	1.子类拥有父类对象所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
	2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展
	3.子类可以用自己的方式实现父类的方法
	
	多态
	所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即
	一个引用变量到底会指向哪个类的实例对象，该变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。
	
	在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）
12. String StringBuffer和StringBuilder的区别是什么？String为什么是不变的？
	可变性
	简单来说：String类中使用final关键字修饰符数据来保存字符串，private final char value[],所以String对象是不变的。StringBuilder与StringBuffer都继承自AbstracStringBuilder类，
	在AbstractStringBuilder中也是使用字符数组来保存字符串char []value 但是没有用final关键字修饰，所以这两种对象是可变的。
	
	StringBuilder和StringBuffer的构造方法都是调用父类构造方法实现的。
	
	线程安全性
	String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder和StringBuffer的公共父类，定义了一些
	字符串的基本操作，StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以线程是安全的。StringBuilder没有对方法加同步锁，所以是非线程安全的
	
	性能
	每次对String类型进行改变的时候，都会生产一个新的String对象，然后将指针指向新的String对象，StringBuffer每次都会对StringBuffer对象本身
	进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuider相比使用StringBuffer仅能获得 10%~15%的性能提升，但却要冒线程不安全的风险。
	
	对于三者的总结：
	1.操作少量的数据：适用String
	2.单线程操作字符串缓冲区下操作大量数据，适用StringBuilder
	3.多线程程序操作字符串缓冲区下操作大量数据：适用StringBuffer
13.自动装箱和拆箱
	装箱：将基本类型用他们对应的引用类型包装
	拆箱：将包装类型转换成基本数据类型
14.在一个静态方法中调用一个非静态成员为什么是非法的？
	由于静态方法可以不通过对象调用，因此在静态方法里，不能该调用其他非静态变量，也不可以访问非静态变量成员/
15.在Java中定义一个不做事且没有参数的构造方法的作用
	Java程序在执行子类的构造方法之前，如果没有用super（）来调用父类特定的构造方法，则会调用父类中
	“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法。而在子类的构造方法中又没有用super（）来调用父类中特定的
	构造方法，则编译时会发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行，解决的办法是在父类里家伙是那个一个不做事且没又参数的构造方法。
16.import java 和javax有什么区别
	刚开始的时候JavaAPI所需要的包是java开头的包，javax当时只是扩展API包来使用。然而随着时间的推移，javax逐渐地成为Java API的组成部分。
	但是将扩展从javax包移动到java包确实太麻烦了，最终会破坏一堆现有的代码。
17.接口和抽象类的区别是什么
	1.接口的方法默认是public，所有方法在接口中不能有实现，而抽象类可以有非抽象的方法。
	2.接口中除了static、final变量，不能有其他变量。
	3.一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
	4.接口方法默认修饰符是public，抽象方法可以有public、protected、default这些修饰符（抽象方法就是为了被重写所以不能用private关键字修饰）
	5.从设计层面来说，抽象是对类的抽象，是一种模板设计。而接口是对行为的抽象，是一种行为的规范。
18.成员变量与局部变量的区别在哪？
	1.从语法上看：成员变量是属于类的，而局部变量是在方法中定义的变量或者是方法的参数；成员变量可以被public，private，static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是成员变量和局部变量都能被final所修饰。
	2.从变量在内存中的存储方式来看：如果成员变量是使用static修饰的，那么这个成员变量是属于类的。如果没有使用static修饰，那么这个成员变量是属于对象实例的。对对象存在于堆内存，局部变量则存在于栈内存。
	3.从变量在内存中的生存时间来看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
	4.成员变量如果没有被赋初值，则会自动一类型的默认值而复制（一种情况除外：被final修饰的成员变量必须显示地赋值），而局部变量不会被自动赋值。
19.创建一个对象用什么运算符？对象实体与对象引用有何不同？
	new运算符，new创建对象实例（对象存在于堆内存中），对象引用执行对象实例（对象引用存放在栈内存中）一个对象引用可以指向0个或者1个对象（1根绳子可以不系气球，也可以系1个气球）
20.什么是方法的返回值？返回值在类的方法里的作用是什么？
	方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果
21.一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行码？
	主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。
22.构造方法有哪些特性？
	1.名字与类名相同。
	2.没有返回值，但不能用void声明构造函数。
	3.生成类的对象时自动执行，无需调用。
23.静态方法和实例方法有何不同
	1.在外部调用静态方法时，可以使用“类名.方法名”的方式，了可以使用“对象名.方法名“的形式。而实例方法只有后面这种。也就是说调用静态方法可以无需创建对象。
	2.静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。
24.对象的相等与指向他们的引用相等，两者有什么不同
	对象的相等，比的是内存存放的内容是否相等，而引用相等，比的是他们指向的内存地址是否相等
25.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？
	帮助子类做初始化工作。
26. ==与equals
	==： 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象（基本数据类型==比较的是值，阴影数据类型==比较的是内存地址）
	equals() 它的作用是判断两个对象是否相等，它有两种使用情况
	1.类没有覆盖该equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
	2.类覆盖了equals()方法。一般，我们都覆盖equals()方法来比较两个对象的内容是否相等，若他们的内容相等，则返回true
	举个例子：
		String a = new String("ab"); // a为一个引用
		String b = new String("ab"); // b为另一个引用
		string aa = "ab"; // 放在常量池中
		String bb = "ab"; // 从常量池中查找
		
		aa=bb; //true
		a==b; // false
		a.equals(b); //true
		42 == 42.0; //true
	说明：
		String中的equals方法是被重写过的，因为object的equals方法是比较对象内存地址，String的equals方法比较的是对象的值。
		当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。
27.hashCode与equals
	hashCode()介绍
	hashCode()的作用是获取哈希码，也被称为散列码；它实际是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()
	定义在JDK的object.java中，这就意味着Java中的任何类都包含有hashCode（）函数
	
	散列表存储的是键值对，它的特点是能根据键快速检索到对应的值，这其中就利用到了散列码！（可以快速找到所需要的对象）
	
	为什么要有hashCode
	我们先以HashSet如何检查重复”为例子来说明为什么要有hashCode: 当你把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode做
	比较，如果没有相符的hasjCode,hashSet会假设对象没有重复出现，但是如果发现有相同hashCode值的对象，这时会调用equals()方法来检查hashCode相等的对象是否相同。如果两者相同，hashSet就不会让其加入操作成功。如果不同的
	话，就会重新散列到其他位置。
	
	hashCode()的作用是获取哈希码，也成为散列码；它实际返回的是一个int整数。这个哈希码的作用是确定这对象在哈希表中的索引位置。
	hashCode()在散列表中才有用。 